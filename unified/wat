12c12
< /*inline void biased_unlock_owner(threaddata * td) 
---
> inline void biased_unlock_owner(threaddata * td) 
16c16
< }*/
---
> }
20c20
< /*inline void incy (int * const y, Lock * l)
---
> inline void incy (int * y, Lock * l)
22c22,25
< 	(*y)++;
---
> 	#ifdef DELAY
> 	for(int j = 0; j < DELAY; j++) ;
> 	#endif	
> 	(*y) = (*y) + 1;
26c29
< }*/
---
> }
45a49
> 	//		if(td->lock->func != NULL) td->lock->func (td->x, td->lock);
50,64c54,55
< 			if(td->lock->token)
< 			{	
< 				switch(td->lock->token)
< 				{
< 					case 1:
< 						#ifdef DELAY
< 						for(int j = 0; j < DELAY; j++) ;
< 						#endif	
< 						*td->x = *td->x + 1;
< 						td->lock->token = 0;
< 						td->lock->done = 1;
< 						asm volatile("mfence");
< 						break;
< 				}
< 			}		
---
> 			if(td->lock->func != NULL) td->lock->func (td->x, td->lock);
> 
67a59
> //		std::cout << "time: " << get_time() - start << std::endl;
74c66
< 		t->tv_nsec = 10000;
---
> 		t->tv_nsec = 1;
80c72
< 			td->lock->token = 1;
---
> 			td->lock->func = &incy;
82c74
< 			while(!(td->lock->done));
---
> 			while((!td->lock->done)){ asm volatile ("pause");}
84c76
< 		//	nanosleep(t,NULL);
---
> //			nanosleep(t,NULL);
92c84
< #define NUM_THREADS 4	
---
> #define NUM_THREADS 4
98c90
< 	lck->token = 0;
---
> 	lck->func = NULL;
100a93,96
> //	int * wat = new int(1);
> //	int * wat2 = new int(1);
> 
> //	std::cout << &lck->n <<std::endl;
110a107,108
> 	void (*fp)(int * y, Lock * l) = &incy;
> 
111a110,111
> 	std::cout << "lck->func: " << lck->func << std::endl;
> 	std::cout << "incy: " << &fp << std::endl;
113,114c113,114
< 	std::cout << "y: " << y << std::endl;
< */	
---
> 	std::cout << "y: " << y << std::endl;*/
> 	
120c120
< 		j[i]->x = x;	
---
> 		j[i]->x = x;
